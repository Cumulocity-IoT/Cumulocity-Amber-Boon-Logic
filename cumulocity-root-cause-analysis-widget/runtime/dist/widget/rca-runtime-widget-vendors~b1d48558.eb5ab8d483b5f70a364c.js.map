{"version":3,"sources":["webpack:///../projects/ng2-charts/src/lib/default-colors.ts","webpack:///../projects/ng2-charts/src/lib/get-colors.ts","webpack:///../projects/ng2-charts/src/lib/theme.service.ts","webpack:///../projects/ng2-charts/src/lib/base-chart.directive.ts","webpack:///../projects/ng2-charts/src/lib/charts.module.ts"],"names":["defaultColors","getColors","chartType","index","count","formatPieColors","generateColors","backgroundColor","colors","map","color","rgba","borderColor","hoverBackgroundColor","hoverBorderColor","pointBackgroundColor","pointBorderColor","pointHoverBackgroundColor","pointHoverBorderColor","formatLineColor","generateColor","formatBarColor","Error","colour","alpha","concat","join","getRandomInt","min","max","Math","floor","random","getRandomColor","colorsArr","Array","i","ThemeService","pColorschemesOptions","colorschemesOptions","options","this","next","providedIn","UpdateType","Default","Update","Refresh","BaseChartDirective","element","themeService","chartClick","chartHover","old","dataExists","dataLength","datasetsExists","datasetsLength","datasetsDataObjects","datasetsDataLengths","colorsExists","labelsExist","labels","legendExists","legend","subs","plugin","register","unregister","ctx","nativeElement","getContext","refresh","push","subscribe","r","themeChanged","chart","updateRequired","wantUpdate","x","data","propagateDataToDatasets","length","datasets","filter","updateColors","colorsEqual","copyColor","labelsEqual","copyLabel","position","update","a","isArray","b","borderWidth","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderWidth","pointRadius","pointHoverRadius","pointHitRadius","pointHoverBorderWidth","pointStyle","hoverBorderWidth","forEach","elm","Object","assign","changes","hasOwnProperty","currentValue","propagateDatasetsToData","config","display","generateLegend","destroy","unsubscribe","duration","hidden","getDatasetMeta","toBase64Image","getDatasets","hover","onHover","event","active","emit","onClick","mergedOptions","smartMerge","getColorschemesOptions","type","plugins","chartConfig","getChartConfiguration","Chart","overrides","level","keys","key","arrayElements","label","isMultiLineLabel","newDataValues","isMultiDataSet","dataset","joinLabel","splice","getChartBuilder","selector","exportAs","ChartsModule","declarations","imports","exports"],"mappings":"khDAAaA,EAAiC,CAC5C,CAAC,IAAK,GAAI,KACV,CAAC,GAAI,IAAK,KACV,CAAC,IAAK,IAAK,IACX,CAAC,IAAK,IAAK,KACX,CAAC,GAAI,IAAK,KACV,CAAC,IAAK,IAAK,KACX,CAAC,IAAK,IAAK,KACX,CAAC,IAAK,GAAI,IACV,CAAC,GAAI,IAAK,KACV,CAAC,IAAK,IAAK,IACX,CAAC,IAAK,IAAK,KACX,CAAC,GAAI,GAAI,K,SCLKC,EAAUC,EAAmBC,EAAeC,GAC1D,GAAkB,QAAdF,GAAqC,aAAdA,EACzB,OAAOG,EAAgBC,EAAeF,IAGxC,GAAkB,cAAdF,EACF,MA8DK,CACLK,iBAF2BC,EA7DEF,EAAeF,IA+DpBK,IAAKC,GAAoBC,EAAKD,EAAO,KAC7DE,YAAaJ,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,IACzDG,qBAAsBL,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,KAClEI,iBAAkBN,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,KALlE,IAA+BF,EA1D7B,GAAkB,SAAdN,GAAsC,UAAdA,EAC1B,OA0BJ,SAAyBM,GACvB,MAAO,CACLD,gBAAiBI,EAAKH,EAAQ,IAC9BI,YAAaD,EAAKH,EAAQ,GAC1BO,qBAAsBJ,EAAKH,EAAQ,GACnCQ,iBAAkB,OAClBC,0BAA2B,OAC3BC,sBAAuBP,EAAKH,EAAQ,KAjC7BW,CAAgBC,EAAcjB,IAGvC,GAAkB,QAAdD,GAAqC,kBAAdA,EACzB,OAiCJ,SAAwBM,GACtB,MAAO,CACLD,gBAAiBI,EAAKH,EAAQ,IAC9BI,YAAaD,EAAKH,EAAQ,GAC1BK,qBAAsBF,EAAKH,EAAQ,IACnCM,iBAAkBH,EAAKH,EAAQ,IAtCxBa,CAAeD,EAAcjB,IAGtC,GAAkB,WAAdD,EACF,OAAOG,EAAgBC,EAAeF,IAGxC,GAAkB,YAAdF,EACF,OAAOG,EAAgBC,EAAeF,IAGxC,MAAM,IAAIkB,MAAM,uCAAyCpB,GAG3D,SAASS,EAAKY,EAAuBC,GACnC,MAAO,QAAUD,EAAOE,OAAOD,GAAOE,KAAK,KAAO,IAGpD,SAASC,EAAaC,EAAaC,GACjC,OAAOC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,IAAMA,EAuBvD,SAASvB,EAAgBG,GACvB,MAAO,CACLD,gBAAiBC,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,KAC7DE,YAAaJ,EAAOC,IAAI,IAAM,QAC9BM,qBAAsBP,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,IAClEM,iBAAkBR,EAAOC,IAAI,IAAM,QACnCQ,0BAA2BT,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,IACvEQ,sBAAuBV,EAAOC,IAAKC,GAAoBC,EAAKD,EAAO,KAavE,SAASuB,IACP,MAAO,CAACN,EAAa,EAAG,KAAMA,EAAa,EAAG,KAAMA,EAAa,EAAG,MAMtE,SAASP,EAAcjB,GACrB,OAAOH,EAAcG,IAAU8B,IAMjC,SAAS3B,EAAeF,G,MAChB8B,EAA6B,IAAIC,MAAM/B,GAC7C,IAAK,IAAIgC,EAAI,EAAGA,EAAIhC,EAAOgC,IACzBF,EAAUE,GAAKpC,EAAcoC,IAAMH,IAErC,OAAOC,E,MC/FIG,EAIX,cAHQ,KAAAC,qBAAqC,GACtC,KAAAC,oBAAsB,IAAI,kBAA8B,IAI/D,uBAAuBC,GACrBC,KAAKH,qBAAuBE,EAC5BC,KAAKF,oBAAoBG,KAAKF,GAGhC,yBACE,OAAOC,KAAKH,sB,oBAff,aAAU,MAAC,CACVK,WAAY,W,8HCoDd,MAAKC,EAAU,CACbC,QAAO,EACPC,OAAM,EACNC,QAAO,G,yEAQIC,EA4CX,YACUC,EACAC,GADA,KAAAD,UACA,KAAAC,eA1CM,KAAAV,QAAwB,GAMvB,KAAAW,WAAkE,IAAI,eACtE,KAAAC,WAAgE,IAAI,eAK7E,KAAAC,IAAgB,CACtBC,YAAY,EACZC,WAAY,EACZC,gBAAgB,EAChBC,eAAgB,EAChBC,oBAAqB,GACrBC,oBAAqB,GACrBC,cAAc,EACdpD,OAAQ,GACRqD,aAAa,EACbC,OAAQ,GACRC,cAAc,EACdC,OAAQ,IAGF,KAAAC,KAAuB,GAKxB,sBAAsBC,GAC3B,gBAAcC,SAASD,GAGlB,wBAAwBA,GAC7B,gBAAcE,WAAWF,GAQpB,WACLzB,KAAK4B,IAAM5B,KAAKQ,QAAQqB,cAAcC,WAAW,MACjD9B,KAAK+B,UACL/B,KAAKwB,KAAKQ,KAAKhC,KAAKS,aAAaX,oBAAoBmC,UAAUC,GAAKlC,KAAKmC,aAAaD,KAGhF,aAAanC,GACnBC,KAAK+B,UAGP,YACE,IAAK/B,KAAKoC,MACR,O,IAEEC,EAAiBlC,EAAWC,Q,MAC1BkC,EAAcC,IAClBF,EAAiBE,EAAIF,EAAiBE,EAAIF,GAkF5C,SA/EMrC,KAAKwC,OAASxC,KAAKY,IAAIC,aAC3Bb,KAAKyC,wBAAwBzC,KAAKwC,MAElCxC,KAAKY,IAAIC,aAAeb,KAAKwC,KAE7BF,EAAWnC,EAAWE,SAGpBL,KAAKwC,MAAQxC,KAAKwC,KAAKE,SAAW1C,KAAKY,IAAIE,aAC7Cd,KAAKY,IAAIE,WAAad,KAAKwC,MAAQxC,KAAKwC,KAAKE,QAAU,EAEvDJ,EAAWnC,EAAWE,WAGlBL,KAAK2C,WAAa3C,KAAKY,IAAIG,iBAC/Bf,KAAKY,IAAIG,iBAAmBf,KAAK2C,SAEjCL,EAAWnC,EAAWE,SAGpBL,KAAK2C,UAAY3C,KAAK2C,SAASD,SAAW1C,KAAKY,IAAII,iBACrDhB,KAAKY,IAAII,eAAiBhB,KAAK2C,UAAY3C,KAAK2C,SAASD,QAAU,EAEnEJ,EAAWnC,EAAWE,SAGpBL,KAAK2C,UAAY3C,KAAK2C,SAASC,OAAO,CAACL,EAAG5C,IAAM4C,EAAEC,OAASxC,KAAKY,IAAIK,oBAAoBtB,IAAI+C,SAC9F1C,KAAKY,IAAIK,oBAAsBjB,KAAK2C,SAAS3E,IAAIuE,GAAKA,EAAEC,MAExDF,EAAWnC,EAAWE,SAGpBL,KAAK2C,UAAY3C,KAAK2C,SAASC,OAAO,CAACL,EAAG5C,IAAM4C,EAAEC,KAAKE,SAAW1C,KAAKY,IAAIM,oBAAoBvB,IAAI+C,SACrG1C,KAAKY,IAAIM,oBAAsBlB,KAAK2C,SAAS3E,IAAIuE,GAAKA,EAAEC,KAAKE,QAE7DJ,EAAWnC,EAAWE,WAGlBL,KAAKjC,SAAWiC,KAAKY,IAAIO,eAC7BnB,KAAKY,IAAIO,eAAiBnB,KAAKjC,OAE/BiC,KAAK6C,eAELP,EAAWnC,EAAWE,SAIpBL,KAAKjC,QAAUiC,KAAKjC,OAAO6E,OAAO,CAACL,EAAG5C,KAAOK,KAAK8C,YAAYP,EAAGvC,KAAKY,IAAI7C,OAAO4B,KAAK+C,SACxF1C,KAAKY,IAAI7C,OAASiC,KAAKjC,OAAOC,IAAIuE,GAAKvC,KAAK+C,UAAUR,IAEtDvC,KAAK6C,eAELP,EAAWnC,EAAWE,WAGlBL,KAAKqB,SAAWrB,KAAKY,IAAIQ,cAC7BpB,KAAKY,IAAIQ,cAAgBpB,KAAKqB,OAE9BiB,EAAWnC,EAAWE,SAGpBL,KAAKqB,QAAUrB,KAAKqB,OAAOuB,OAAO,CAACL,EAAG5C,KAAOK,KAAKgD,YAAYT,EAAGvC,KAAKY,IAAIS,OAAO1B,KAAK+C,SACxF1C,KAAKY,IAAIS,OAASrB,KAAKqB,OAAOrD,IAAIuE,GAAKvC,KAAKiD,UAAUV,IAEtDD,EAAWnC,EAAWE,WAGlBL,KAAKD,QAAQwB,SAAWvB,KAAKY,IAAIU,eACrCtB,KAAKY,IAAIU,eAAiBtB,KAAKD,QAAQwB,OAEvCe,EAAWnC,EAAWG,UAGpBN,KAAKD,QAAQwB,QAAUvB,KAAKD,QAAQwB,OAAO2B,WAAalD,KAAKY,IAAIW,OAAO2B,WAC1ElD,KAAKY,IAAIW,OAAO2B,SAAWlD,KAAKD,QAAQwB,OAAO2B,SAE/CZ,EAAWnC,EAAWG,UAGhB,GACN,KAAKH,EAAWC,QACd,MACF,KAAKD,EAAWE,OACdL,KAAKmD,SACL,MACF,KAAKhD,EAAWG,QACdN,KAAK+B,WAKX,UAAUqB,GACR,OAAI1D,MAAM2D,QAAQD,GACT,IAAIA,GAENA,EAGT,YAAYA,EAAUE,GACpB,OAAO5D,MAAM2D,QAAQD,KAAO1D,MAAM2D,QAAQC,KACpC5D,MAAM2D,QAAQD,IAAMA,IAAME,MACzB5D,MAAM2D,QAAQD,IAAMA,EAAEV,SAAWY,EAAEZ,WACnChD,MAAM2D,QAAQD,IAAgD,IAA1CA,EAAER,OAAO,CAACL,EAAG5C,IAAM4C,IAAMe,EAAE3D,IAAI+C,QAI5D,UAAUU,GACR,MAAO,CACLtF,gBAAiBsF,EAAEtF,gBACnByF,YAAaH,EAAEG,YACfpF,YAAaiF,EAAEjF,YACfqF,eAAgBJ,EAAEI,eAClBC,WAAYL,EAAEK,WACdC,iBAAkBN,EAAEM,iBACpBC,gBAAiBP,EAAEO,gBACnBpF,iBAAkB6E,EAAE7E,iBACpBD,qBAAsB8E,EAAE9E,qBACxBsF,iBAAkBR,EAAEQ,iBACpBC,YAAaT,EAAES,YACfC,iBAAkBV,EAAEU,iBACpBC,eAAgBX,EAAEW,eAClBvF,0BAA2B4E,EAAE5E,0BAC7BC,sBAAuB2E,EAAE3E,sBACzBuF,sBAAuBZ,EAAEY,sBACzBC,WAAYb,EAAEa,WACd7F,qBAAsBgF,EAAEhF,qBACxBC,iBAAkB+E,EAAE/E,iBACpB6F,iBAAkBd,EAAEc,kBAIxB,YAAYd,EAAUE,GACpB,OAAKF,IAAOE,KAGJF,GACLA,EAAEtF,kBAAoBwF,EAAExF,iBACrBsF,EAAEG,cAAgBD,EAAEC,aACpBH,EAAEjF,cAAgBmF,EAAEnF,aACpBiF,EAAEI,iBAAmBF,EAAEE,gBACvBJ,EAAEK,aAAeH,EAAEG,YACnBL,EAAEM,mBAAqBJ,EAAEI,kBACzBN,EAAEO,kBAAoBL,EAAEK,iBACxBP,EAAE7E,mBAAqB+E,EAAE/E,kBACzB6E,EAAE9E,uBAAyBgF,EAAEhF,sBAC7B8E,EAAEQ,mBAAqBN,EAAEM,kBACzBR,EAAES,cAAgBP,EAAEO,aACpBT,EAAEU,mBAAqBR,EAAEQ,kBACzBV,EAAEW,iBAAmBT,EAAES,gBACvBX,EAAE5E,4BAA8B8E,EAAE9E,2BAClC4E,EAAE3E,wBAA0B6E,EAAE7E,uBAC9B2E,EAAEY,wBAA0BV,EAAEU,uBAC9BZ,EAAEa,aAAeX,EAAEW,YACnBb,EAAEhF,uBAAyBkF,EAAElF,sBAC7BgF,EAAE/E,mBAAqBiF,EAAEjF,kBACzB+E,EAAEc,mBAAqBZ,EAAEY,kBAGjC,eACElE,KAAK2C,SAASwB,QAAQ,CAACC,EAAK1G,KACtBsC,KAAKjC,QAAUiC,KAAKjC,OAAOL,GAC7B2G,OAAOC,OAAOF,EAAKpE,KAAKjC,OAAOL,IAE/B2G,OAAOC,OAAOF,EAAK5G,EAAUwC,KAAKvC,UAAWC,EAAO0G,EAAI5B,KAAKE,QAAS,OAAF,UAAO0B,MAK1E,YAAYG,G,IACblC,EAAiBlC,EAAWC,Q,MAC1BkC,EAAcC,IAClBF,EAAiBE,EAAIF,EAAiBE,EAAIF,GAsC5C,OAjCIkC,EAAQC,eAAe,SAAWD,EAAQ/B,KAAKiC,eACjDzE,KAAKyC,wBAAwB8B,EAAQ/B,KAAKiC,cAE1CnC,EAAWnC,EAAWE,SAGpBkE,EAAQC,eAAe,aAAeD,EAAQ5B,SAAS8B,eACzDzE,KAAK0E,wBAAwBH,EAAQ5B,SAAS8B,cAE9CnC,EAAWnC,EAAWE,SAGpBkE,EAAQC,eAAe,YACrBxE,KAAKoC,QACPpC,KAAKoC,MAAMI,KAAKnB,OAASkD,EAAQlD,OAAOoD,cAG1CnC,EAAWnC,EAAWE,SAGpBkE,EAAQC,eAAe,YACrBxE,KAAKoC,QACPpC,KAAKoC,MAAMuC,OAAO5E,QAAQwB,OAAOqD,QAAUL,EAAQhD,OAAOkD,aAC1DzE,KAAKoC,MAAMyC,kBAGbvC,EAAWnC,EAAWE,SAGpBkE,EAAQC,eAAe,YACzBlC,EAAWnC,EAAWG,SAGhB,GACN,KAAKH,EAAWE,OACdL,KAAKmD,SACL,MACF,KAAKhD,EAAWG,QAChB,KAAKH,EAAWC,QACdJ,KAAK+B,WAKJ,cACD/B,KAAKoC,QACPpC,KAAKoC,MAAM0C,UACX9E,KAAKoC,WAAQ,GAEfpC,KAAKwB,KAAK2C,QAAQ5B,GAAKA,EAAEwC,eAGpB,OAAOC,GACZ,GAAIhF,KAAKoC,MACP,OAAOpC,KAAKoC,MAAMe,OAAO6B,GAItB,YAAYtH,EAAeuH,GAChCjF,KAAKoC,MAAM8C,eAAexH,GAAOuH,OAASA,EAC1CjF,KAAKoC,MAAMe,SAGN,gBAAgBzF,GACrB,OAAOsC,KAAKoC,MAAM8C,eAAexH,GAAOuH,OAGnC,gBACL,OAAOjF,KAAKoC,MAAM+C,gBAGb,wB,MACCxC,EAAW3C,KAAKoF,cAEhBrF,EAAUsE,OAAOC,OAAO,GAAItE,KAAKD,UACnB,IAAhBC,KAAKuB,SACPxB,EAAQwB,OAAS,CAAEqD,SAAS,IAG9B7E,EAAQsF,MAAQtF,EAAQsF,OAAS,GAC5BtF,EAAQsF,MAAMC,UACjBvF,EAAQsF,MAAMC,QAAU,CAACC,EAAmBC,KACtCA,IAAWA,EAAO9C,QAGtB1C,KAAKW,WAAW8E,KAAK,CAAEF,QAAOC,aAI7BzF,EAAQ2F,UACX3F,EAAQ2F,QAAU,CAACH,EAAoBC,KACrCxF,KAAKU,WAAW+E,KAAK,CAAEF,QAAOC,a,MAI5BG,EAAgB3F,KAAK4F,WAAW7F,EAASC,KAAKS,aAAaoF,0BAEjE,MAAO,CACLC,KAAM9F,KAAKvC,UACX+E,KAAM,CACJnB,OAAQrB,KAAKqB,QAAU,GACvBsB,YAEFoD,QAAS/F,KAAK+F,QACdhG,QAAS4F,GAIN,gBAAgB/D,G,MACfoE,EAAchG,KAAKiG,wBACzB,OAAO,IAAIC,QAAMtE,EAAKoE,GAGxB,WAAWjG,EAAcoG,EAAgBC,EAAgB,GACzC,IAAVA,IACFrG,EAAU,kBAAUA,IAoBtB,GAlBqBsE,OAAOgC,KAAKF,GACpBhC,QAAQmC,IACnB,GAAI5G,MAAM2D,QAAQ8C,EAAUG,IAAO,C,MAC3BC,EAAgBxG,EAAQuG,GAC1BC,GACFA,EAAcpC,QAAQjC,IACpBlC,KAAK4F,WAAW1D,EAAGiE,EAAUG,GAAK,GAAIF,EAAQ,SAGb,iBAApBD,EAAUG,IACrBA,KAAOvG,IACXA,EAAQuG,GAAO,IAEjBtG,KAAK4F,WAAW7F,EAAQuG,GAAMH,EAAUG,GAAMF,EAAQ,IAEtDrG,EAAQuG,GAAOH,EAAUG,KAGf,IAAVF,EACF,OAAOrG,EAIH,iBAAiByG,GACvB,OAAO9G,MAAM2D,QAAQmD,GAGf,UAAUA,GAChB,OAAKA,EAGDxG,KAAKyG,iBAAiBD,GACjBA,EAAMvH,KAAK,KAEXuH,EALA,KASH,wBAAwB7D,GAC9B3C,KAAKwC,KAAOxC,KAAK2C,SAAS3E,IAAIkE,GAAKA,EAAEM,MACjCxC,KAAKoC,QACPpC,KAAKoC,MAAMI,KAAKG,SAAWA,GAE7B3C,KAAK6C,eAGC,wBAAwB6D,GAC1B1G,KAAK2G,eAAeD,GAClB1G,KAAK2C,UAAY+D,EAAchE,SAAW1C,KAAK2C,SAASD,OAC1D1C,KAAK2C,SAASwB,QAAQ,CAACyC,EAASjH,KAC9BiH,EAAQpE,KAAOkE,EAAc/G,MAG/BK,KAAK2C,SAAW+D,EAAc1I,IAAI,CAACwE,EAAgB9E,KAC1C,CAAE8E,OAAMgE,MAAOxG,KAAK6G,UAAU7G,KAAKqB,OAAO3D,KAAW,SAASA,KAEnEsC,KAAKoC,QACPpC,KAAKoC,MAAMI,KAAKG,SAAW3C,KAAK2C,WAI/B3C,KAAK2C,UAMH3C,KAAK2C,SAAS,KACjB3C,KAAK2C,SAAS,GAAK,IAGrB3C,KAAK2C,SAAS,GAAGH,KAAOkE,EACxB1G,KAAK2C,SAASmE,OAAO,KAVrB9G,KAAK2C,SAAW,CAAC,CAAEH,KAAMkE,IACrB1G,KAAKoC,QACPpC,KAAKoC,MAAMI,KAAKG,SAAW3C,KAAK2C,WAWtC3C,KAAK6C,eAGC,eAAeL,GACrB,OAAO9C,MAAM2D,QAAQb,EAAK,IAGpB,cACN,IAAKxC,KAAK2C,WAAa3C,KAAKwC,KAC1B,MAAM,IAAI3D,MAAM,sFAAuFmB,KAAKvC,WAI9G,OAAIuC,KAAK2C,UACP3C,KAAK0E,wBAAwB1E,KAAK2C,UAC3B3C,KAAK2C,UAGV3C,KAAKwC,MACPxC,KAAKyC,wBAAwBzC,KAAKwC,MAC3BxC,KAAK2C,eAFd,EAMM,UAMF3C,KAAKoC,QACPpC,KAAKoC,MAAM0C,UACX9E,KAAKoC,WAAQ,GAEXpC,KAAK4B,MACP5B,KAAKoC,MAAQpC,KAAK+G,gBAAgB/G,KAAK4B,O,oBA5d5C,YAAS,MAAC,CAEToF,SAAU,oBACVC,SAAU,iB,4BA9DV,c,MAWOrH,I,8BAsDN,U,gBACA,U,cACA,U,eACA,U,iBACA,U,cACA,U,cACA,U,eACA,U,kBAEA,W,kBACA,Y,MClEUsH,G,oBAVZ,WAAQ,MAAC,CACRC,aAAc,CACZ5G,GAEF6G,QAAS,GAETC,QAAS,CACP9G","file":"rca-runtime-widget-vendors~b1d48558.eb5ab8d483b5f70a364c.js","sourcesContent":["export const defaultColors: Array<number[]> = [\n  [255, 99, 132],\n  [54, 162, 235],\n  [255, 206, 86],\n  [231, 233, 237],\n  [75, 192, 192],\n  [151, 187, 205],\n  [220, 220, 220],\n  [247, 70, 74],\n  [70, 191, 189],\n  [253, 180, 92],\n  [148, 159, 177],\n  [77, 83, 96]\n];\n","import { Color } from './color';\nimport { Colors } from './colors';\nimport { defaultColors } from './default-colors';\n\n/**\n * Generate colors by chart type\n */\nexport function getColors(chartType: string, index: number, count: number): Color {\n  if (chartType === 'pie' || chartType === 'doughnut') {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === 'polarArea') {\n    return formatPolarAreaColors(generateColors(count));\n  }\n\n  if (chartType === 'line' || chartType === 'radar') {\n    return formatLineColor(generateColor(index));\n  }\n\n  if (chartType === 'bar' || chartType === 'horizontalBar') {\n    return formatBarColor(generateColor(index));\n  }\n\n  if (chartType === 'bubble') {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === 'scatter') {\n    return formatPieColors(generateColors(count));\n  }\n\n  throw new Error('getColors - Unsupported chart type: ' + chartType);\n}\n\nfunction rgba(colour: Array<number>, alpha: number): string {\n  return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n\nfunction getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction formatLineColor(colors: Array<number>): Color {\n  return {\n    backgroundColor: rgba(colors, 0.4),\n    borderColor: rgba(colors, 1),\n    pointBackgroundColor: rgba(colors, 1),\n    pointBorderColor: '#fff',\n    pointHoverBackgroundColor: '#fff',\n    pointHoverBorderColor: rgba(colors, 0.8)\n  };\n}\n\nfunction formatBarColor(colors: Array<number>): Color {\n  return {\n    backgroundColor: rgba(colors, 0.6),\n    borderColor: rgba(colors, 1),\n    hoverBackgroundColor: rgba(colors, 0.8),\n    hoverBorderColor: rgba(colors, 1)\n  };\n}\n\nfunction formatPieColors(colors: Array<number[]>): Colors {\n  return {\n    backgroundColor: colors.map((color: number[]) => rgba(color, 0.6)),\n    borderColor: colors.map(() => '#fff'),\n    pointBackgroundColor: colors.map((color: number[]) => rgba(color, 1)),\n    pointBorderColor: colors.map(() => '#fff'),\n    pointHoverBackgroundColor: colors.map((color: number[]) => rgba(color, 1)),\n    pointHoverBorderColor: colors.map((color: number[]) => rgba(color, 1))\n  };\n}\n\nfunction formatPolarAreaColors(colors: Array<number[]>): Color {\n  return {\n    backgroundColor: colors.map((color: number[]) => rgba(color, 0.6)),\n    borderColor: colors.map((color: number[]) => rgba(color, 1)),\n    hoverBackgroundColor: colors.map((color: number[]) => rgba(color, 0.8)),\n    hoverBorderColor: colors.map((color: number[]) => rgba(color, 1))\n  };\n}\n\nfunction getRandomColor(): number[] {\n  return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n\n/**\n * Generate colors for line|bar charts\n */\nfunction generateColor(index: number): number[] {\n  return defaultColors[index] || getRandomColor();\n}\n\n/**\n * Generate colors for pie|doughnut charts\n */\nfunction generateColors(count: number): Array<number[]> {\n  const colorsArr: Array<number[]> = new Array(count);\n  for (let i = 0; i < count; i++) {\n    colorsArr[i] = defaultColors[i] || getRandomColor();\n  }\n  return colorsArr;\n}\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { ChartOptions } from 'chart.js';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ThemeService {\n  private pColorschemesOptions: ChartOptions = {};\n  public colorschemesOptions = new BehaviorSubject<ChartOptions>({});\n\n  constructor() { }\n\n  setColorschemesOptions(options: ChartOptions): void {\n    this.pColorschemesOptions = options;\n    this.colorschemesOptions.next(options);\n  }\n\n  getColorschemesOptions(): ChartOptions {\n    return this.pColorschemesOptions;\n  }\n}\n","import {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { getColors } from './get-colors';\nimport { Color } from './color';\nimport { ThemeService } from './theme.service';\nimport { Subscription } from 'rxjs';\nimport { cloneDeep } from 'lodash-es';\nimport {\n  Chart,\n  ChartConfiguration,\n  ChartDataSets,\n  ChartOptions,\n  ChartPoint, ChartType,\n  PluginServiceGlobalRegistration,\n  PluginServiceRegistrationOptions,\n  pluginService\n} from 'chart.js';\n\nexport type SingleDataSet = Array<number | null | undefined | number[]> | ChartPoint[];\nexport type MultiDataSet = SingleDataSet[];\nexport type SingleOrMultiDataSet = SingleDataSet | MultiDataSet;\n\nexport type PluginServiceGlobalRegistrationAndOptions =\n  PluginServiceGlobalRegistration\n  & PluginServiceRegistrationOptions;\nexport type SingleLineLabel = string;\nexport type MultiLineLabel = string[];\nexport type Label = SingleLineLabel | MultiLineLabel;\n\ninterface OldState {\n  dataExists: boolean;\n  dataLength: number;\n  datasetsExists: boolean;\n  datasetsLength: number;\n  datasetsDataObjects: any[];\n  datasetsDataLengths: number[];\n  colorsExists: boolean;\n  colors: Color[];\n  labelsExist: boolean;\n  labels: Label[];\n  legendExists: boolean;\n  legend: {\n    position?: string;\n  };\n}\n\nenum UpdateType {\n  Default,\n  Update,\n  Refresh\n}\n\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: 'canvas[baseChart]',\n  exportAs: 'base-chart'\n})\nexport class BaseChartDirective implements OnChanges, OnInit, OnDestroy, DoCheck {\n  @Input() public data: SingleOrMultiDataSet;\n  @Input() public datasets: ChartDataSets[];\n  @Input() public labels: Label[];\n  @Input() public options: ChartOptions = {};\n  @Input() public chartType: ChartType;\n  @Input() public colors: Color[];\n  @Input() public legend: boolean;\n  @Input() public plugins: PluginServiceGlobalRegistrationAndOptions[];\n\n  @Output() public chartClick: EventEmitter<{ event?: MouseEvent, active?: {}[] }> = new EventEmitter();\n  @Output() public chartHover: EventEmitter<{ event: MouseEvent, active: {}[] }> = new EventEmitter();\n\n  public ctx: string;\n  public chart: Chart;\n\n  private old: OldState = {\n    dataExists: false,\n    dataLength: 0,\n    datasetsExists: false,\n    datasetsLength: 0,\n    datasetsDataObjects: [],\n    datasetsDataLengths: [],\n    colorsExists: false,\n    colors: [],\n    labelsExist: false,\n    labels: [],\n    legendExists: false,\n    legend: {},\n  };\n\n  private subs: Subscription[] = [];\n\n  /**\n   * Register a plugin.\n   */\n  public static registerPlugin(plugin: PluginServiceGlobalRegistrationAndOptions): void {\n    pluginService.register(plugin);\n  }\n\n  public static unregisterPlugin(plugin: PluginServiceGlobalRegistrationAndOptions): void {\n    pluginService.unregister(plugin);\n  }\n\n  public constructor(\n    private element: ElementRef,\n    private themeService: ThemeService,\n  ) { }\n\n  public ngOnInit(): void {\n    this.ctx = this.element.nativeElement.getContext('2d');\n    this.refresh();\n    this.subs.push(this.themeService.colorschemesOptions.subscribe(r => this.themeChanged(r)));\n  }\n\n  private themeChanged(options: {}): void {\n    this.refresh();\n  }\n\n  ngDoCheck(): void {\n    if (!this.chart) {\n      return;\n    }\n    let updateRequired = UpdateType.Default;\n    const wantUpdate = (x: UpdateType) => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n\n    if (!!this.data !== this.old.dataExists) {\n      this.propagateDataToDatasets(this.data);\n\n      this.old.dataExists = !!this.data;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.data && this.data.length !== this.old.dataLength) {\n      this.old.dataLength = this.data && this.data.length || 0;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.datasets !== this.old.datasetsExists) {\n      this.old.datasetsExists = !!this.datasets;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\n      this.old.datasetsLength = this.datasets && this.datasets.length || 0;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.datasets && this.datasets.filter((x, i) => x.data !== this.old.datasetsDataObjects[i]).length) {\n      this.old.datasetsDataObjects = this.datasets.map(x => x.data);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.datasets && this.datasets.filter((x, i) => x.data.length !== this.old.datasetsDataLengths[i]).length) {\n      this.old.datasetsDataLengths = this.datasets.map(x => x.data.length);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.colors !== this.old.colorsExists) {\n      this.old.colorsExists = !!this.colors;\n\n      this.updateColors();\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    // This smells of inefficiency, might need to revisit this\n    if (this.colors && this.colors.filter((x, i) => !this.colorsEqual(x, this.old.colors[i])).length) {\n      this.old.colors = this.colors.map(x => this.copyColor(x));\n\n      this.updateColors();\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.labels !== this.old.labelsExist) {\n      this.old.labelsExist = !!this.labels;\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (this.labels && this.labels.filter((x, i) => !this.labelsEqual(x, this.old.labels[i])).length) {\n      this.old.labels = this.labels.map(x => this.copyLabel(x));\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (!!this.options.legend !== this.old.legendExists) {\n      this.old.legendExists = !!this.options.legend;\n\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    if (this.options.legend && this.options.legend.position !== this.old.legend.position) {\n      this.old.legend.position = this.options.legend.position;\n\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    switch (updateRequired as UpdateType) {\n      case UpdateType.Default:\n        break;\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n        this.refresh();\n        break;\n    }\n  }\n\n  copyLabel(a: Label): Label {\n    if (Array.isArray(a)) {\n      return [...a];\n    }\n    return a;\n  }\n\n  labelsEqual(a: Label, b: Label): boolean {\n    return Array.isArray(a) === Array.isArray(b)\n      && (Array.isArray(a) || a === b)\n      && (!Array.isArray(a) || a.length === b.length)\n      && (!Array.isArray(a) || a.filter((x, i) => x !== b[i]).length === 0)\n      ;\n  }\n\n  copyColor(a: Color): Color {\n    return {\n      backgroundColor: a.backgroundColor,\n      borderWidth: a.borderWidth,\n      borderColor: a.borderColor,\n      borderCapStyle: a.borderCapStyle,\n      borderDash: a.borderDash,\n      borderDashOffset: a.borderDashOffset,\n      borderJoinStyle: a.borderJoinStyle,\n      pointBorderColor: a.pointBorderColor,\n      pointBackgroundColor: a.pointBackgroundColor,\n      pointBorderWidth: a.pointBorderWidth,\n      pointRadius: a.pointRadius,\n      pointHoverRadius: a.pointHoverRadius,\n      pointHitRadius: a.pointHitRadius,\n      pointHoverBackgroundColor: a.pointHoverBackgroundColor,\n      pointHoverBorderColor: a.pointHoverBorderColor,\n      pointHoverBorderWidth: a.pointHoverBorderWidth,\n      pointStyle: a.pointStyle,\n      hoverBackgroundColor: a.hoverBackgroundColor,\n      hoverBorderColor: a.hoverBorderColor,\n      hoverBorderWidth: a.hoverBorderWidth,\n    };\n  }\n\n  colorsEqual(a: Color, b: Color): boolean {\n    if (!a !== !b) {\n      return false;\n    }\n    return !a ||\n      (a.backgroundColor === b.backgroundColor)\n      && (a.borderWidth === b.borderWidth)\n      && (a.borderColor === b.borderColor)\n      && (a.borderCapStyle === b.borderCapStyle)\n      && (a.borderDash === b.borderDash)\n      && (a.borderDashOffset === b.borderDashOffset)\n      && (a.borderJoinStyle === b.borderJoinStyle)\n      && (a.pointBorderColor === b.pointBorderColor)\n      && (a.pointBackgroundColor === b.pointBackgroundColor)\n      && (a.pointBorderWidth === b.pointBorderWidth)\n      && (a.pointRadius === b.pointRadius)\n      && (a.pointHoverRadius === b.pointHoverRadius)\n      && (a.pointHitRadius === b.pointHitRadius)\n      && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)\n      && (a.pointHoverBorderColor === b.pointHoverBorderColor)\n      && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)\n      && (a.pointStyle === b.pointStyle)\n      && (a.hoverBackgroundColor === b.hoverBackgroundColor)\n      && (a.hoverBorderColor === b.hoverBorderColor)\n      && (a.hoverBorderWidth === b.hoverBorderWidth);\n  }\n\n  updateColors(): void {\n    this.datasets.forEach((elm, index) => {\n      if (this.colors && this.colors[index]) {\n        Object.assign(elm, this.colors[index]);\n      } else {\n        Object.assign(elm, getColors(this.chartType, index, elm.data.length), { ...elm });\n      }\n    });\n  }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    let updateRequired = UpdateType.Default;\n    const wantUpdate = (x: UpdateType) => {\n      updateRequired = x > updateRequired ? x : updateRequired;\n    };\n\n    // Check if the changes are in the data or datasets or labels or legend\n\n    if (changes.hasOwnProperty('data') && changes.data.currentValue) {\n      this.propagateDataToDatasets(changes.data.currentValue);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {\n      this.propagateDatasetsToData(changes.datasets.currentValue);\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty('labels')) {\n      if (this.chart) {\n        this.chart.data.labels = changes.labels.currentValue;\n      }\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty('legend')) {\n      if (this.chart) {\n        this.chart.config.options.legend.display = changes.legend.currentValue;\n        this.chart.generateLegend();\n      }\n\n      wantUpdate(UpdateType.Update);\n    }\n\n    if (changes.hasOwnProperty('options')) {\n      wantUpdate(UpdateType.Refresh);\n    }\n\n    switch (updateRequired as UpdateType) {\n      case UpdateType.Update:\n        this.update();\n        break;\n      case UpdateType.Refresh:\n      case UpdateType.Default:\n        this.refresh();\n        break;\n    }\n  }\n\n  public ngOnDestroy(): void {\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    this.subs.forEach(x => x.unsubscribe());\n  }\n\n  public update(duration?: any): {} {\n    if (this.chart) {\n      return this.chart.update(duration);\n    }\n  }\n\n  public hideDataset(index: number, hidden: boolean): void {\n    this.chart.getDatasetMeta(index).hidden = hidden;\n    this.chart.update();\n  }\n\n  public isDatasetHidden(index: number): boolean {\n    return this.chart.getDatasetMeta(index).hidden;\n  }\n\n  public toBase64Image(): string {\n    return this.chart.toBase64Image();\n  }\n\n  public getChartConfiguration(): ChartConfiguration {\n    const datasets = this.getDatasets();\n\n    const options = Object.assign({}, this.options);\n    if (this.legend === false) {\n      options.legend = { display: false };\n    }\n    // hook for onHover and onClick events\n    options.hover = options.hover || {};\n    if (!options.hover.onHover) {\n      options.hover.onHover = (event: MouseEvent, active: {}[]) => {\n        if (active && !active.length) {\n          return;\n        }\n        this.chartHover.emit({ event, active });\n      };\n    }\n\n    if (!options.onClick) {\n      options.onClick = (event?: MouseEvent, active?: {}[]) => {\n        this.chartClick.emit({ event, active });\n      };\n    }\n\n    const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());\n\n    return {\n      type: this.chartType,\n      data: {\n        labels: this.labels || [],\n        datasets\n      },\n      plugins: this.plugins,\n      options: mergedOptions,\n    };\n  }\n\n  public getChartBuilder(ctx: string/*, data:any[], options:any*/): Chart {\n    const chartConfig = this.getChartConfiguration();\n    return new Chart(ctx, chartConfig);\n  }\n\n  smartMerge(options: any, overrides: any, level: number = 0): any {\n    if (level === 0) {\n      options = cloneDeep(options);\n    }\n    const keysToUpdate = Object.keys(overrides);\n    keysToUpdate.forEach(key => {\n      if (Array.isArray(overrides[key])) {\n        const arrayElements = options[key];\n        if (arrayElements) {\n          arrayElements.forEach(r => {\n            this.smartMerge(r, overrides[key][0], level + 1);\n          });\n        }\n      } else if (typeof (overrides[key]) === 'object') {\n        if (!(key in options)) {\n          options[key] = {};\n        }\n        this.smartMerge(options[key], overrides[key], level + 1);\n      } else {\n        options[key] = overrides[key];\n      }\n    });\n    if (level === 0) {\n      return options;\n    }\n  }\n\n  private isMultiLineLabel(label: Label): label is MultiLineLabel {\n    return Array.isArray(label);\n  }\n\n  private joinLabel(label: Label): string {\n    if (!label) {\n      return null;\n    }\n    if (this.isMultiLineLabel(label)) {\n      return label.join(' ');\n    } else {\n      return label;\n    }\n  }\n\n  private propagateDatasetsToData(datasets: ChartDataSets[]): void {\n    this.data = this.datasets.map(r => r.data);\n    if (this.chart) {\n      this.chart.data.datasets = datasets;\n    }\n    this.updateColors();\n  }\n\n  private propagateDataToDatasets(newDataValues: SingleOrMultiDataSet): void {\n    if (this.isMultiDataSet(newDataValues)) {\n      if (this.datasets && newDataValues.length === this.datasets.length) {\n        this.datasets.forEach((dataset, i: number) => {\n          dataset.data = newDataValues[i];\n        });\n      } else {\n        this.datasets = newDataValues.map((data: number[], index: number) => {\n          return { data, label: this.joinLabel(this.labels[index]) || `Label ${index}` };\n        });\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      }\n    } else {\n      if (!this.datasets) {\n        this.datasets = [{ data: newDataValues }];\n        if (this.chart) {\n          this.chart.data.datasets = this.datasets;\n        }\n      } else {\n        if (!this.datasets[0]) {\n          this.datasets[0] = {};\n        }\n\n        this.datasets[0].data = newDataValues;\n        this.datasets.splice(1); // Remove all elements but the first\n      }\n    }\n    this.updateColors();\n  }\n\n  private isMultiDataSet(data: SingleOrMultiDataSet): data is MultiDataSet {\n    return Array.isArray(data[0]);\n  }\n\n  private getDatasets(): Chart.ChartDataSets[] {\n    if (!this.datasets && !this.data) {\n      throw new Error(`ng-charts configuration error, data or datasets field are required to render chart ${ this.chartType }`);\n    }\n\n    // If `datasets` is defined, use it over the `data` property.\n    if (this.datasets) {\n      this.propagateDatasetsToData(this.datasets);\n      return this.datasets;\n    }\n\n    if (this.data) {\n      this.propagateDataToDatasets(this.data);\n      return this.datasets;\n    }\n  }\n\n  private refresh(): void {\n    // if (this.options && this.options.responsive) {\n    //   setTimeout(() => this.refresh(), 50);\n    // }\n\n    // todo: remove this line, it is producing flickering\n    if (this.chart) {\n      this.chart.destroy();\n      this.chart = void 0;\n    }\n    if (this.ctx) {\n      this.chart = this.getChartBuilder(this.ctx/*, data, this.options*/);\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { BaseChartDirective } from './base-chart.directive';\n\n@NgModule({\n  declarations: [\n    BaseChartDirective\n  ],\n  imports: [\n  ],\n  exports: [\n    BaseChartDirective\n  ]\n})\nexport class ChartsModule { }\n"],"sourceRoot":""}