{"version":3,"sources":["webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/gp-lib-rca.service.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/Commonc8yservice.service.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/rca-view-modal/rca-view-modal.component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/gp-lib-rca.component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/gp-lib-rca.config.component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/color-picker/color-picker-component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/color-picker/color-slider/color-slider-component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/color-picker/color-palette/color-palette-component.ts","webpack:///C:/Widgets/Angular11/projects/gp-lib-rca/src/lib/gp-lib-rca.module.ts"],"names":["res","allDevices","name","inventoryFilter","allAdditions","allInventoryItems","data","mo","device","fragmentSeries","supportedMeasurements","fragementList","measurementType","existingF","this","label","barChartData","length","borderColor","measurementData","msmt","allSubscriptions","response","mes","valueFragmentType","iteam","console","log","chart","value","selectedRCAMeasurements","moment","time","format","forEach","color","measurementRCAType","isOpenCP","borderCP","config","rgba","toString","r","g","b","a","event","ctx","gradient","addColorStop","whiteGrad","blackGrad","pos"],"mappings":"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","file":"rca-runtime-widget-CustomWidget.8884293b51a90acbae50.js","sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class GpLibRcaService {\n  constructor() {}\n}\n","/**\n * Copyright (c) 2020 Software AG, Darmstadt, Germany and/or its licensors\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isDevMode, Injectable } from '@angular/core';\nimport {\n  InventoryBinaryService,\n  FetchClient,\n  InventoryService,\n  IManagedObject,\n  IResultList,\n  MeasurementService,\n  IFetchOptions,\n  IdReference,\n} from '@c8y/client';\nimport { debounceTime, distinctUntilChanged, tap, switchMap, finalize, skip } from 'rxjs/operators';\nimport { BehaviorSubject, from, Observable, Observer } from 'rxjs';\n\n@Injectable()\nexport class Commonc8yService {\n  devices: any[] = [];\n  statusResponse!: any;\n\n  constructor(\n    private invSvc: InventoryService,\n    private msmtSvc: MeasurementService,\n    private inventoryBinaryService: InventoryBinaryService,\n    private fetchClient: FetchClient\n  ) {}\n\n  getTargetObject(deviceId: String): any {\n    if (isDevMode()) {\n      console.log('+-+- checking for ', deviceId);\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.detail(deviceId).then((resp) => {\n        if (isDevMode()) {\n          console.log('+-+- DETAILS FOR MANAGED OBJECT ' + deviceId, resp);\n        }\n        if (resp.res.status === 200) {\n          resolve(resp.data);\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  /**\n   * This service will recursively get all the child devices for the given device id and return a promise with the result list.\n   *\n   * @param id ID of the managed object to check for child devices\n   * @param pageToGet Number of the page passed to the API\n   * @param allDevices Child Devices already found\n   */\n  getChildDevices(\n    id: string,\n    pageToGet: number,\n    allDevices: { data: any[]; res: any }\n  ): Promise<IResultList<IManagedObject>> {\n    const inventoryFilter = {\n      // fragmentType: 'c8y_IsDevice',\n      pageSize: 50,\n      withTotalPages: true,\n      currentPage: pageToGet,\n    };\n    if (!allDevices) {\n      allDevices = { data: [], res: null };\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.childAssetsList(id, inventoryFilter).then((resp: any) => {\n        if (resp.res.status === 200) {\n          if (resp.data && resp.data.length >= 0) {\n            allDevices.data.push.apply(allDevices.data, resp.data);\n            if (isDevMode()) {\n              console.log('+-+- checking on devices found\\n', resp);\n            }\n            // response does not have totalPages... :(\n            // suppose that if # of devices is less that the page size, then all devices have already been retrieved\n            if (resp.data.length < inventoryFilter.pageSize) {\n              resolve(allDevices);\n            } else {\n              this.getChildDevices(id, resp.paging.nextPage, allDevices)\n                .then((np) => {\n                  resolve(allDevices);\n                })\n                .catch((err) => reject(err));\n            }\n          }\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  // Regular expression for validation\n  generateRegEx(input: any) {\n    const name = input + '';\n    const nameLower = name.toLowerCase();\n    const nameUpper = name.toUpperCase();\n    let regex = '*';\n    const numRegex = new RegExp(/^([0-9]+)$/);\n    const splCharRegex = new RegExp(/^([,._-]+)$/);\n    for (let i = 0; i < name.length; i++) {\n      if (name.charAt(i) === ' ') {\n        regex += ' ';\n      } else if (name.charAt(i).match(numRegex)) {\n        regex += '[' + name.charAt(i) + ']';\n      } else if (name.charAt(i).match(splCharRegex)) {\n        regex += '[' + name.charAt(i) + ']';\n      } else {\n        regex += '[' + nameLower.charAt(i) + '|' + nameUpper.charAt(i) + ']';\n      }\n    }\n    regex += '*';\n    return regex;\n  }\n\n  // Get All devices based on query search parameter\n\n  getAllDevices(pageToGet: number, searchName?: any): Promise<IResultList<IManagedObject>> {\n    let inventoryFilter: any = {};\n    inventoryFilter = {\n      pageSize: 10,\n      withTotalPages: true,\n      currentPage: pageToGet,\n    };\n    if (searchName) {\n      inventoryFilter['query'] = `$filter=(has(c8y_IsDevice) and (name eq '${this.generateRegEx(\n        searchName\n      )}'))`;\n    } else {\n      inventoryFilter['query'] = `$filter=(has(c8y_IsDevice))`;\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.list(inventoryFilter).then((resp) => {\n        if (resp.res.status === 200) {\n          resolve(resp);\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  /**\n   * This service will recursively get all the child devices for the given device id.\n   *\n   * @param id ID of the managed object to check for child additions\n   * @param pageToGet Number of the page passed to the API\n   * @param allAdditions Child additions already found... the newly found additions will be aded here\n   * @param type Type of addition to return... the service does not use the \"fragmentType\"\n   */\n  getChildAdditions(\n    id: string,\n    pageToGet: number,\n    allAdditions: { data: any[]; res: any },\n    type: string\n  ): Promise<IResultList<IManagedObject>> {\n    const inventoryFilter = {\n      // fragmentType: type,\n      // valueFragmentType: type,\n      // type: type,\n      pageSize: 15,\n      withTotalPages: true,\n      currentPage: pageToGet,\n    };\n    if (!allAdditions) {\n      allAdditions = { data: [], res: null };\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.childAdditionsList(id, inventoryFilter).then((resp: any) => {\n        if (resp.res.status === 200) {\n          if (resp.data && resp.data.length >= 0) {\n            allAdditions.data.push.apply(allAdditions.data, resp.data);\n            if (isDevMode()) {\n              console.log('+-+- checking on additions found\\n', resp);\n            }\n            // response does not have totalPages... :(\n            // suppose that if # of devices is less that the page size, then all devices have already been retrieved\n            if (resp.data.length < inventoryFilter.pageSize) {\n              allAdditions.data = allAdditions.data.filter((d) => {\n                return d.type && d.type.localeCompare(type) === 0;\n              });\n              resolve(allAdditions);\n            } else {\n              this.getChildAdditions(id, resp.paging.nextPage, allAdditions, type)\n                .then((np) => {\n                  resolve(allAdditions);\n                })\n                .catch((err) => reject(err));\n            }\n          }\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  /**\n   * Get Inventory list based on type\n   */\n  getInventoryItems(\n    pageToGet: number,\n    allInventoryItems: { data: any[]; res: any },\n    type: string\n  ): Promise<IResultList<IManagedObject>> {\n    let inventoryFilter: any;\n    inventoryFilter = {\n      pageSize: 50,\n      withTotalPages: true,\n      currentPage: pageToGet,\n      query: `type eq ${type}`,\n    };\n    if (!allInventoryItems) {\n      allInventoryItems = { data: [], res: null };\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.list(inventoryFilter).then((resp: any) => {\n        if (resp.res.status === 200) {\n          if (resp.data && resp.data.length >= 0) {\n            allInventoryItems.data.push.apply(allInventoryItems.data, resp.data);\n            if (isDevMode()) {\n              console.log('+-+- checking on inventory items found\\n', resp);\n            }\n            // response does not have totalPages... :(\n            // suppose that if # of devices is less that the page size, then all devices have already been retrieved\n            if (resp.data.length < inventoryFilter.pageSize) {\n              // remove the additions that does not fit into the given type, if any\n              resolve(allInventoryItems);\n            } else {\n              this.getInventoryItems(resp.paging.nextPage, allInventoryItems, type)\n                .then((np) => {\n                  resolve(allInventoryItems);\n                })\n                .catch((err) => reject(err));\n            }\n          }\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  getSpecificFragmentDevices(\n    pageToGet: number,\n    searchName?: any\n  ): Promise<IResultList<IManagedObject>> {\n    let inventoryFilter: any = {};\n    inventoryFilter = {\n      pageSize: 10,\n      withTotalPages: true,\n      currentPage: pageToGet,\n    };\n    if (searchName) {\n      inventoryFilter[\n        'query'\n      ] = `$filter=(has(c8y_IsDevice) and (has(c8y_AmberSensorConfiguration)) and (name eq '${this.generateRegEx(\n        searchName\n      )}'))`;\n    } else {\n      inventoryFilter[\n        'query'\n      ] = `$filter=(has(c8y_IsDevice)) and (has(c8y_AmberSensorConfiguration)) `;\n    }\n    return new Promise((resolve, reject) => {\n      this.invSvc.list(inventoryFilter).then((resp) => {\n        if (resp.res.status === 200) {\n          resolve(resp);\n        } else {\n          reject(resp);\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates the given object using the InventoryService.\n   *\n   * @param managedObject Object to be created\n   * @returns Promise object with the result of the service call\n   */\n  createManagedObject(managedObject: Partial<IManagedObject>): Promise<any> {\n    if (isDevMode()) {\n      console.log('+-+- CREATING MANAGED OBJECT ');\n    }\n\n    return this.invSvc.create(managedObject);\n    /* return new Promise(\n             (resolve, reject) => {\n                 this.invSvc.create(managedObject)\n                     .then((resp) => {\n                         if (isDevMode()) { console.log('+-+- DETAILS FOR MANAGED OBJECT CREATION', resp); }\n                         // successful return code is 201 Created\n                         if (resp.res.status === 201) {\n                             resolve(resp.data);\n                         } else {\n                             reject(resp);\n                         }\n                     });\n             }); */\n  }\n\n  updateManagedObject(managedObject: Partial<IManagedObject>): Promise<any> {\n    if (isDevMode()) {\n      console.log('+-+- CREATING MANAGED OBJECT ');\n    }\n\n    return this.invSvc.update(managedObject);\n  }\n\n  deleteManagedObject(id: IdReference): Promise<any> {\n    return this.invSvc.delete(id);\n  }\n\n  /**\n   *\n   * @param input Validate JSON Input\n   */\n  isValidJson(input: any) {\n    try {\n      if (input) {\n        const o = JSON.parse(input);\n        if (o && o.constructor === Object) {\n          return o;\n        }\n      }\n    } catch (e) {}\n    return false;\n  }\n\n  /**\n   * This method used in configuration of this widget to populate available measurements for given device id or group id\n   */\n  getFragmentSeries(\n    aDevice: any,\n    fragementList: any,\n    observableFragment$: BehaviorSubject<any>\n  ): void {\n    let deviceList: any = null;\n    if (aDevice) {\n      // get all child assets for the target object, defined in the configuration\n      this.getTargetObject(aDevice.id)\n        .then(async (mo: any) => {\n          if (\n            mo &&\n            mo.type &&\n            (mo.type.localeCompare('c8y_DeviceGroup') === 0 ||\n              mo.type.localeCompare('c8y_DeviceSubgroup') === 0)\n          ) {\n            // GET child devices\n            this.getChildDevices(aDevice.id, 1, deviceList)\n              .then(async (deviceFound) => {\n                deviceList = deviceFound.data;\n                const uniqueDeviceList = deviceList\n                  .filter(\n                    (device: any, index: any, self: any) =>\n                      index === self.findIndex((t: any) => t.type === device.type)\n                  )\n                  .map((device: any) => device.id);\n                for (const device of uniqueDeviceList) {\n                  if (isDevMode()) {\n                    console.log('+-+- CHECKING Series FOR: ', device);\n                  }\n                  const supportedMeasurements = await this.getSupportedMeasurementsForDevice(\n                    device\n                  );\n                  if (isDevMode()) {\n                    console.log(\n                      '+-+- supportedMeasurements FOR... ' + device,\n                      supportedMeasurements\n                    );\n                  }\n                  const fragmentSeries = await this.getSupportedSeriesForDevice(device);\n                  if (isDevMode()) {\n                    console.log('+-+- FragmentSeries FOR... ' + device, fragmentSeries);\n                  }\n                  if (\n                    fragmentSeries &&\n                    fragmentSeries.c8y_SupportedSeries &&\n                    supportedMeasurements &&\n                    supportedMeasurements.c8y_SupportedMeasurements\n                  ) {\n                    fragementList = this.getFragementList(\n                      fragementList,\n                      fragmentSeries.c8y_SupportedSeries,\n                      supportedMeasurements.c8y_SupportedMeasurements\n                    );\n                  }\n                }\n                observableFragment$.next(fragementList);\n              })\n              .catch((err) => {\n                if (isDevMode()) {\n                  console.log('+-+- ERROR FOUND WHILE GETTING CHILD DEVICES... ', err);\n                }\n              });\n          } else {\n            if (isDevMode()) {\n              console.log('+-+- CHECKING MEASUREMENTS FOR: ', aDevice.id);\n            }\n            const supportedMeasurements = await this.getSupportedMeasurementsForDevice(aDevice.id);\n            if (isDevMode()) {\n              console.log('+-+- supportedMeasurements FOR... ' + aDevice.id, supportedMeasurements);\n            }\n            const fragmentSeries = await this.getSupportedSeriesForDevice(aDevice.id);\n            if (isDevMode()) {\n              console.log('+-+- FragmentSeries FOR... ' + aDevice.id, fragmentSeries);\n            }\n            if (\n              fragmentSeries &&\n              fragmentSeries.c8y_SupportedSeries &&\n              supportedMeasurements &&\n              supportedMeasurements.c8y_SupportedMeasurements\n            ) {\n              fragementList = this.getFragementList(\n                fragementList,\n                fragmentSeries.c8y_SupportedSeries,\n                supportedMeasurements.c8y_SupportedMeasurements\n              );\n            }\n            observableFragment$.next(fragementList);\n          }\n        })\n        .catch((err: any) => {\n          if (isDevMode()) {\n            console.log('+-+- ERROR while getting Device details ', err);\n          }\n        });\n    }\n  }\n  // This method populate measurementList/fragementList based on series and measurements\n  private getFragementList(fragementList: any, fragmentSeries: any, supportedMeasurements: any) {\n    if (fragementList) {\n      fragmentSeries.forEach((fs: string) => {\n        const measurementType = supportedMeasurements.filter(\n          (smFilter: string) => fs.indexOf(smFilter) !== -1\n        );\n        if (measurementType && measurementType.length > 0) {\n          const fsName = fs.replace(measurementType[0] + '.', '');\n          const fsType = measurementType[0];\n          const existingF = fragementList.find(\n            (sm: { type: any; name: string }) => sm.type === fsType && sm.name === fsName\n          );\n          if (!existingF || existingF == null) {\n            fragementList.push({\n              name: fsName,\n              type: fsType,\n              description: fs,\n            });\n          }\n        }\n      });\n    } else {\n      fragmentSeries.forEach((fs: string) => {\n        const measurementType = supportedMeasurements.filter(\n          (smFilter: string) => fs.indexOf(smFilter) !== -1\n        );\n        if (measurementType && measurementType.length > 0) {\n          const fsName = fs.replace(measurementType[0] + '.', '');\n          const fsType = measurementType[0];\n          fragementList.push({\n            name: fsName,\n            type: fsType,\n            description: fs,\n          });\n        }\n      });\n    }\n    return fragementList;\n  }\n  // Get Supported Series for given device id/\n  private async getSupportedSeriesForDevice(deviceId: string) {\n    const options: IFetchOptions = {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n    };\n    return await (\n      await this.fetchClient.fetch(`/inventory/managedObjects/${deviceId}/supportedSeries`, options)\n    ).json();\n  }\n  // Get Supported Measurements for given device Id\n  private async getSupportedMeasurementsForDevice(deviceId: string) {\n    const options: IFetchOptions = {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' },\n    };\n    return await (\n      await this.fetchClient.fetch(\n        `/inventory/managedObjects/${deviceId}/supportedMeasurements`,\n        options\n      )\n    ).json();\n  }\n  // tslint:disable-next-line:max-line-length\n  getLastMeasurementForSource(\n    sourceId: string,\n    dateFrom: string,\n    dateTo: string,\n    type: string,\n    series: string\n  ): Promise<IResultList<IManagedObject>> {\n    const msmtFilter = {\n      pageSize: 20,\n      valueFragmentSeries: series,\n      valueFragmentType: type,\n      dateFrom,\n      dateTo,\n      revert: true,\n      source: sourceId,\n      // type\n    };\n\n    return new Promise((resolve) => {\n      this.msmtSvc.list(msmtFilter).then((resp: any) => {\n        resolve(resp);\n      });\n    });\n  }\n\n  getMeasurementForSource(\n    sourceId: string,\n    dateFrom: string,\n    dateTo: string,\n    type: string\n  ): Promise<IResultList<IManagedObject>> {\n    const msmtFilter = {\n      pageSize: 10,\n      valueFragmentType: type,\n      dateFrom,\n      dateTo,\n      revert: true,\n      source: sourceId,\n      // type\n    };\n\n    return new Promise((resolve) => {\n      this.msmtSvc.list(msmtFilter).then((resp: any) => {\n        resolve(resp);\n      });\n    });\n  }\n}\n","import { Component, Input, isDevMode, OnInit, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';\nimport {\n  ActionControl,\n  Column,\n  ColumnDataType,\n  ConfirmModalComponent,\n  DataGridComponent,\n  gettext,\n  ModalLabels,\n  Pagination,\n  Status,\n  StatusType,\n} from '@c8y/ngx-components';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { Commonc8yService } from '../Commonc8yservice.service';\nimport { debounceTime, distinctUntilChanged, tap, switchMap, finalize, skip } from 'rxjs/operators';\n\n@Component({\n  selector: 'rca-view-modal',\n  templateUrl: 'rca-view-modal.component.html',\n  styleUrls: ['./styles.less'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class RCAViewModalComponent implements OnInit {\n  @ViewChild(DataGridComponent, { static: true })\n  @Input()\n  device!: any;\n  @Input() label!: any;\n  @Input() value!: any;\n  @Input() rcaDataset!: any;\n  @Input() configcolor!: any;\n  @Input() configborderColor!: any;\n\n  public barChartType = '';\n  public barChartData: any;\n  public barChartLabels: any;\n  public barChartColors = [];\n  colorsArr = [];\n  dataLoaded: Promise<boolean> | undefined;\n  bsModalRefOption!: BsModalRef;\n  public barChartOptions = {\n    scaleShowVerticalLines: false,\n    responsive: true,\n    legend: {\n      title: {\n        display: true,\n        text: 'RCA',\n      },\n      position: 'top',\n      display: true,\n    },\n    scales: {},\n    elements: {\n      line: {\n        fill: false,\n      },\n    },\n  };\n  measurementList = [];\n  observableMeasurements$ = new BehaviorSubject<any>(this.measurementList);\n  measurementType: any;\n  measurementTypeList: any;\n  measurementSubs: any;\n\n  constructor(\n    private cmonSvc: Commonc8yService,\n    private bsModalRef: BsModalRef,\n    private bsModalService: BsModalService\n  ) {}\n\n  async ngOnInit(): Promise<void> {\n    this.barChartOptions['scales'] = {\n      xAxes: [\n        {\n          ticks: {\n            beginAtZero: true,\n            font: {\n              size: 6,\n            },\n          },\n        },\n      ],\n      yAxes: [\n        {\n          ticks: {\n            beginAtZero: true,\n            stepSize: 0.2,\n          },\n        },\n      ],\n    };\n    this.createchart();\n  }\n  async createchart() {\n    let k: any;\n    const dataValues: any[] = [];\n    const labels: string[] = [];\n    const dataResult = {};\n    this.barChartLabels = [];\n    this.barChartData = [];\n    this.rcaDataset.forEach((iteam: any) => {\n      labels.push(iteam.key);\n      dataValues.push(iteam.value);\n    });\n    console.log('dataValues ', dataValues);\n    let dlabels = labels.map((l) => l.split('-'));\n    let vlabels: any[] = [];\n    dlabels.forEach((label: any) => {\n      vlabels.push(label[1]);\n    });\n    if (dataValues.length > 0) {\n      this.barChartLabels = vlabels;\n      this.barChartData = [{ data: dataValues, label: 'Amber Route Cause' }];\n      this.barChartType = 'bar';\n      this.dataLoaded = Promise.resolve(true);\n    }\n    this.setChartColors();\n    console.log('barChartData', this.barChartData);\n  }\n  setChartColors() {\n    let borderColor = [];\n    if (this.configcolor !== undefined) {\n      this.colorsArr = this.configcolor.split(';');\n      if (this.configborderColor === undefined || this.configborderColor === '') {\n        borderColor = [];\n      } else {\n        borderColor = this.configborderColor.split(';');\n      }\n\n      if (this.configcolor === '') {\n        this.barChartColors = [];\n      } else if (this.colorsArr.length >= this.barChartData.length) {\n        for (let k = 0; k < this.barChartData.length; k++) {\n          this.barChartColors.push({\n            backgroundColor: this.colorsArr[k],\n            // @ts-ignore\n            borderColor,\n          });\n        }\n      } else if (this.barChartData[0].data.length <= this.colorsArr.length) {\n        if (borderColor.length < this.barChartData[0].data.length) {\n          borderColor = [];\n        }\n        this.barChartColors = [\n          {\n            // @ts-ignore\n            backgroundColor: this.colorsArr,\n            // @ts-ignore\n            borderColor,\n          },\n        ];\n      } else {\n        this.barChartColors = [];\n      }\n    } else {\n      this.barChartColors = [];\n    }\n  }\n\n  public onCancelClicked() {\n    this.bsModalRef.hide();\n  }\n}\n","import { Component, OnInit, Input, OnDestroy, isDevMode } from '@angular/core';\nimport { InventoryService, Realtime, MeasurementService } from '@c8y/client';\nimport { Commonc8yService } from './Commonc8yservice.service';\nimport { AlertService } from '@c8y/ngx-components';\nimport {\n  debounceTime,\n  distinctUntilChanged,\n  tap,\n  switchMap,\n  finalize,\n  skip,\n  min,\n  max,\n} from 'rxjs/operators';\nimport { BehaviorSubject, from, never, Observable, Observer } from 'rxjs';\nimport { time } from 'console';\nimport * as moment_ from 'moment';\nimport { DatePipe } from '@angular/common';\nimport { Subject } from 'rxjs/internal/Subject';\nimport { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';\nimport { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';\nimport { RCAViewModalComponent } from './rca-view-modal/rca-view-modal.component';\nimport { analyzeAndValidateNgModules } from '@angular/compiler';\nconst moment = moment_;\n\n@Component({\n  selector: 'lib-gp-lib-rca',\n  templateUrl: './gp-lib-rca.component.html',\n  styleUrls: ['./gp-lib-rca.component.css'],\n})\nexport class GpLibRcaComponent implements OnInit {\n  @Input() config: any;\n  deviceId: any;\n  device: any;\n  measurementList = [];\n  observableMeasurements$ = new BehaviorSubject<any>(this.measurementList);\n  measurementType: any;\n  measurementTypeList: any;\n  measurementSubs: any;\n  valueFragmentType: any;\n  valueFragmentSeries: any;\n  selectedRCAMeasurements: any;\n  oldDataset: any;\n  public barChartOptions = {\n    scaleShowVerticalLines: false,\n    responsive: true,\n    legend: {\n      position: 'top',\n      display: true,\n    },\n    scales: {},\n    elements: {\n      line: {\n        fill: false,\n      },\n    },\n  };\n  public barChartType = '';\n  public barChartData: any;\n  public barChartLabels: any;\n  public barChartColors = [];\n  colorsArr = [];\n  dataLoaded: Promise<boolean> | undefined;\n  bsModalRefOption!: BsModalRef;\n  rcaDataset: { key: string; value: any }[] = [];\n  borderColor: any;\n  realtimeState = true;\n  interval: any;\n  protected allSubscriptions: any = [];\n  constructor(\n    private cmonSvc: Commonc8yService,\n    private alertervice: AlertService,\n    private measurementService: MeasurementService,\n    private formBuilder: FormBuilder,\n    private modalService: BsModalService,\n    private realTimeService: Realtime\n  ) {}\n\n  async ngOnInit(): Promise<void> {\n    this.deviceId = this.config.device.id;\n    this.selectedRCAMeasurements = this.config.selectedRCAMeasurements;\n    this.interval = this.config.interval;\n    // this.interval = \"Last Hour\";\n    //     this.selectedRCAMeasurements = [\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_0\",\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_1\",\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_2\",\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_3\",\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_4\",\n    //     \"c8y_AmberRootCause.c8y_SignalStrength-actual_current_5\",\n    // ];\n    // this.deviceId = 8492;\n    //   this.selectedRCAMeasurements = [\n    //     \"c8y_AmberRootCause.c8y_comp-gb_hss_de\",\n    //     \"c8y_AmberRootCause.c8y_comp-gb_hss_nde\",\n    //     \"c8y_AmberRootCause.c8y_comp-comp_female_nde\",\n    //     \"c8y_AmberRootCause.c8y_comp-gb_lss_nde\",\n    //     \"c8y_AmberRootCause.c8y_comp-gb_lss_de\",\n    //     \"c8y_AmberRootCause.c8y_comp-mtr_nde\",\n    //     \"c8y_AmberRootCause.c8y_comp-mtr_de\",\n    //     \"c8y_AmberRootCause.c8y_comp-comp_male_de\",\n    //     \"c8y_AmberRootCause.c8y_comp-comp_male_nde\",\n    //     \"c8y_AmberRootCause.c8y_comp-comp_female_de\"\n    // ];\n    //   this.deviceId = 1380;\n    this.barChartOptions['scales'] = {\n      xAxes: [\n        {\n          ticks: {\n            beginAtZero: true,\n            font: {\n              size: 6,\n            },\n          },\n        },\n      ],\n      yAxes: [\n        {\n          min: 0,\n          max: 2,\n          ticks: {\n            beginAtZero: true,\n            stepSize: 1,\n          },\n        },\n      ],\n    };\n    await this.LoadDeviceData();\n    if (this.realtimeState) {\n      this.allSubscriptions = [];\n      this.realtTimeMeasurements(this.deviceId);\n    }\n  }\n\n  async refresh() {\n    this.clearSubscriptions();\n    await this.LoadDeviceData();\n  }\n  /** Toggles the realtime state */\n  async toggle() {\n    this.realtimeState = !this.realtimeState;\n    if (this.realtimeState) {\n      this.allSubscriptions = [];\n      this.realtTimeMeasurements(this.deviceId);\n    }\n    else {\n      this.clearSubscriptions();\n    }\n  }\n  private realtTimeMeasurements(deviceId:any) {\n\n    const measurementChannel = `/measurements/${deviceId}`;\n    const detailSubs  = this.realTimeService.subscribe(\n      measurementChannel,\n      async (response: { data: any; }) => {\n        if (response && response.data) {\n          const measurementData = response.data;\n          if ( measurementData.data) \n          {\n            const msmt = measurementData.data;\n            if ( msmt && msmt[this.valueFragmentType] && msmt[this.valueFragmentType][this.valueFragmentSeries])\n            {\n              if (isDevMode()) {console.log(\"msmt\",msmt);}\n              await this.LoadDeviceData(); \n            }\n          }\n        }\n      }\n      );\n      if (this.realtimeState) {\n        this.allSubscriptions.push({\n          id: this.deviceId,\n          subs: detailSubs,\n          type: 'Realtime',\n        });\n      } else {\n        this.realTimeService.unsubscribe(detailSubs);\n      }\n    }\n \n\n  private clearSubscriptions() {\n    if (this.allSubscriptions) {\n      this.allSubscriptions.forEach((s: any) => {\n        this.realTimeService.unsubscribe(s.subs);\n      });\n    }\n  }\n  async LoadDeviceData() {\n    this.device = await this.cmonSvc.getTargetObject(this.deviceId);\n    let response = await this.cmonSvc.getSpecificFragmentDevices(1, this.device.name);\n    if (isDevMode()) {\n      console.log('+-+- MANAGED OBJECT WITH AMBER FRAGMENT', response.data);\n    }\n    if (response.data) {\n      await this.getmeasurement();\n    } else {\n      this.alertervice.danger('Device is not configured to Amber');\n    }\n  }\n  async checkFargmentSeries() {\n    this.measurementList.forEach((ml: any) => {\n      if (ml.name === 'ad') {\n        if (isDevMode()) {\n          console.log('+-+-c8y_ad.ad measurement exist');\n        }\n        this.valueFragmentType = 'c8y_ad';\n        this.valueFragmentSeries = 'ad';\n      }\n    });\n\n    if (this.valueFragmentSeries && this.valueFragmentType && this.device.id) {\n      await this.createChart(this.device.id);\n    }\n  }\n\n  async getmeasurement() {\n    if (this.device && this.device.id) {\n      const response = await this.cmonSvc.getTargetObject(this.device.id);\n      await this.cmonSvc.getFragmentSeries(\n        response,\n        this.measurementList,\n        this.observableMeasurements$\n      );\n      if (!this.measurementType) {\n        this.measurementType = {};\n      } else {\n        if (this.measurementTypeList.length > 0) {\n          let measurementType;\n          for (measurementType of this.measurementTypeList) {\n            if (this.measurementType.name === measurementType.name) {\n              this.measurementType = measurementType;\n            }\n          }\n        }\n      }\n\n      // Get the measurements as soon as device or group is selected\n      this.measurementSubs = this.observableMeasurements$\n        .pipe(skip(1))\n        // tslint:disable-next-line: deprecation\n        .subscribe(async (mes) => {\n          this.measurementTypeList = [];\n          if (mes && mes.length > 0) {\n            this.measurementTypeList = [...mes];\n            if (isDevMode()) {\n              console.log('+-+- CHECKING LIST MEASUREMENTS FOR: ', this.measurementTypeList);\n            }\n            await this.checkFargmentSeries();\n          }\n        });\n    }\n  }\n\n  /** Fetches the events using Event Service for the given device and particular event type */\n  async createChart(deviceId: any) {\n    const now = moment();\n    var totime = moment(now, 'YYYY-MM-DD HH:mm:ss').format();\n    let dataSet: { key: string; value: any }[] = [];\n    var fromtime: any;\n    if (this.interval === 'Last Hour') {\n      fromtime = moment(totime).subtract(2, 'hours').format();\n    } else if (this.interval === 'Last Minute') {\n      fromtime = moment(totime).subtract(1, 'minutes').format();\n    } else if (this.interval === '' || this.interval === undefined) {\n      fromtime = moment(totime).subtract(1, 'hours').format();\n    }\n    if (isDevMode()) {console.log('fromtime - totime', fromtime);}\n    const response = (await this.cmonSvc.getLastMeasurementForSource(\n      deviceId,\n      fromtime,\n      totime,\n      this.valueFragmentType,\n      this.valueFragmentSeries\n    )) as any;\n\n    if (isDevMode()) {\n      console.log('+-+- Measurement data: ', response);\n    }\n    if (response && response.data.length > 0) {\n      response.data.forEach((mes: any) => {\n        if (\n          mes &&\n          mes[this.valueFragmentType] &&\n          mes[this.valueFragmentType][this.valueFragmentSeries]\n        ) {\n          const date = moment(mes.time).format('YYYY-MM-DD HH:mm:ss');\n          const value = mes[this.valueFragmentType][this.valueFragmentSeries].value;\n          let arr = { key: date, value: value };\n          dataSet.push(arr);\n        }\n      });\n      if (isDevMode()) {\n      console.log('dataset', dataSet);}\n      dataSet.reverse();\n      if (isDevMode()) {\n      console.log('+-+- val: ', dataSet);}\n      let k: any;\n      const dataValues: any[] = [];\n      const labels: string[] = [];\n      const dataResult = {};\n      this.barChartLabels = [];\n      this.barChartData = [];\n\n      dataSet.forEach((iteam) => {\n        labels.push(moment(iteam.key).format('YYYY-MM-DD HH:mm:ss'));\n        dataValues.push(iteam.value);\n      });\n      if (isDevMode()) {\n      console.log('dataValues ', dataValues);\n      console.log('labels', labels);\n      }\n      let dlabels = labels.map((l) => l.split(' '));\n\n      if (dataValues.length > 0) {\n        this.barChartLabels = dlabels;\n        this.barChartData = [{ data: dataValues, label: 'AD' }];\n        this.barChartType = 'line';\n        this.dataLoaded = Promise.resolve(true);\n      }\n      this.setChartColors();\n      if (isDevMode()) {\n      console.log('barChartData', this.barChartData);}\n    }\n  }\n\n  public chartClicked(event: any): void {\n    if (isDevMode()) {console.log('event', event);}\n    if (event.active.length > 0) {\n      const chart = event.active[0]._chart;\n      const activePoints = chart.getElementsAtEventForMode(event.event, 'point', chart.options);\n      const firstPoint = activePoints[0];\n      const label = chart.data.labels[firstPoint._index];\n      const value = chart.data.datasets[firstPoint._datasetIndex].data[firstPoint._index];\n      if (value > 0) {\n        this.displayModalDialog(label, value);\n      }\n    } else {\n      if (isDevMode()) {\n      console.log('there is no active element');}\n      return;\n    }\n  }\n  async getRCAValue(time: string, setfalg: any) {\n    this.rcaDataset = [];\n    let fragment: any;\n    let series: { key: string }[] = [];\n    let response: any;\n    if (this.selectedRCAMeasurements.length > 0) {\n      this.selectedRCAMeasurements.forEach(async (fs: any) => {\n        let values = fs.split('.', 2);\n        fragment = values[0];\n        series.push(values[1]);\n      });\n      if (setfalg === 1) {\n        var fromtime = moment(time).subtract(1, 'minutes').format();\n        var totime = moment(time, 'YYYY-MM-DD HH:mm:ss').format();\n        response = (await this.cmonSvc.getMeasurementForSource(\n          this.deviceId,\n          fromtime,\n          totime,\n          fragment\n        )) as any;\n      } else if (setfalg === 0) {\n        var totime = moment(time).add(1, 'minutes').format();\n        var fromtime = moment(time, 'YYYY-MM-DD HH:mm:ss').format();\n        response = (await this.cmonSvc.getMeasurementForSource(\n          this.deviceId,\n          fromtime,\n          totime,\n          fragment\n        )) as any;\n      }\n      if (isDevMode()) {console.log('response', response);}\n      if (response && response.data.length === 1) {\n        response.data.forEach((mes: any) => {\n          series.forEach((series: any) => {\n            if (mes && mes[fragment]) {\n              const value = mes[fragment][series].value;\n              let arr = { key: series, value: value };\n              this.rcaDataset.push(arr);\n            }\n          });\n        });\n      } else if (response && response.data.length > 1) {\n        const resp = response.data[response.data.length - 1];\n        series.forEach((series: any) => {\n          if (series) {\n            const value = resp[fragment][series].value;\n            let arr = { key: series, value: value };\n            this.rcaDataset.push(arr);\n          }\n        });\n      }\n    }\n  }\n  public async displayModalDialog(time: any, value: any) {\n    let ctime = time.join(' ');\n    let dataset: any;\n    let setflag = 1;\n    await this.getRCAValue(ctime, setflag);\n\n    if (isDevMode()) {console.log('rcaDataset', this.rcaDataset);}\n\n    if (this.rcaDataset.length === 0) {\n      setflag = 0;\n      await this.getRCAValue(ctime, setflag);\n      if (isDevMode()) {console.log('rcaDataset inner fnction', this.rcaDataset);}\n    }\n\n    const initialState = {\n      device: this.deviceId,\n      time: ctime,\n      value: value,\n      rcaDataset: this.rcaDataset,\n      configcolor: this.config.color,\n      configborderColor: this.config.borderColor,\n    };\n    this.bsModalRefOption = this.modalService.show(RCAViewModalComponent, {\n      initialState,\n      // class: 'modal-sm',\n    });\n  }\n\n  setChartColors() {\n    let borderColor = [];\n    if (this.config.color !== undefined) {\n      this.colorsArr = this.config.color.split(';');\n      if (this.config.borderColor === undefined || this.config.borderColor === '') {\n        borderColor = [];\n      } else {\n        borderColor = this.config.borderColor.split(';');\n      }\n\n      if (this.config.color === '') {\n        this.barChartColors = [];\n      } else if (this.colorsArr.length >= this.barChartData.length) {\n        for (let k = 0; k < this.barChartData.length; k++) {\n          this.barChartColors.push({\n            backgroundColor: this.colorsArr[k],\n            // @ts-ignore\n            borderColor,\n          });\n        }\n      } else if (this.barChartData[0].data.length <= this.colorsArr.length) {\n        if (borderColor.length < this.barChartData[0].data.length) {\n          borderColor = [];\n        }\n        this.barChartColors = [\n          {\n            // @ts-ignore\n            backgroundColor: this.colorsArr,\n            // @ts-ignore\n            borderColor,\n          },\n        ];\n      } else {\n        this.barChartColors = [];\n      }\n    } else {\n      this.barChartColors = [];\n    }\n  }\n  ngOnDestroy(): void {\n    this.clearSubscriptions();\n  }\n}\n","import { Component, Input, isDevMode, OnInit } from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup } from '@angular/forms';\nimport { MeasurementService } from '@c8y/client';\nimport { AlertService } from '@c8y/ngx-components';\nimport { BehaviorSubject } from 'rxjs';\nimport { Commonc8yService } from './Commonc8yservice.service';\nimport { debounceTime, distinctUntilChanged, tap, switchMap, finalize, skip } from 'rxjs/operators';\n\n@Component({\n  selector: 'lib-gp-lib-config-rca',\n  templateUrl: './gp-lib-rca.config.component.html',\n  styleUrls: ['./gp-lib-rca.component.css'],\n})\nexport class GpLibRcaConfigComponent implements OnInit {\n  @Input() config: any = {};\n  measurementRCAList = [];\n  observableMeasurements$ = new BehaviorSubject<any>(this.measurementRCAList);\n  measurementRCAType: any;\n  ListMeasurementType: any;\n  measurementSubs: any;\n  isOpenCP = false;\n  borderCP = false;\n  deviceId: any;\n\n  rcaMeasuremntDeviceForm = new FormGroup({\n    rcadevicemeasure: new FormControl(),\n    intervalSelect: new FormControl(),\n    chartcolor: new FormControl(),\n    bordercolor: new FormControl(),\n  });\n\n  constructor(\n    private cmonSvc: Commonc8yService,\n    private alertervice: AlertService,\n    private measurementService: MeasurementService,\n    private formBuilder: FormBuilder\n  ) {}\n\n  async ngOnInit() {\n    if (this.config.device && this.config.device.id) {\n      this.deviceId = this.config.device.id;\n      await this.getmeasurement();\n    }\n  }\n\n  async getmeasurement() {\n    if (this.deviceId) {\n      const response = await this.cmonSvc.getTargetObject(this.deviceId);\n      await this.cmonSvc.getFragmentSeries(\n        response,\n        this.measurementRCAList,\n        this.observableMeasurements$\n      );\n      if (!this.measurementRCAType) {\n        this.measurementRCAType = {};\n      } else {\n        if (this.ListMeasurementType.length > 0) {\n          let measurementType;\n          for (measurementType of this.ListMeasurementType) {\n            if (this.measurementRCAType.name === measurementType.name) {\n              this.measurementRCAType = measurementType;\n            }\n          }\n        }\n      }\n\n      // Get the measurements as soon as device or group is selected\n      this.measurementSubs = this.observableMeasurements$\n        .pipe(skip(1))\n        // tslint:disable-next-line: deprecation\n        .subscribe(async (mes) => {\n          this.ListMeasurementType = [];\n          if (mes && mes.length > 0) {\n            this.ListMeasurementType = [...mes];\n            if (isDevMode()) {\n              console.log('+-+- CHECKING LIST MEASUREMENTS FOR: ', this.ListMeasurementType);\n            }\n          }\n        });\n    }\n  }\n\n  invokeSetRCA() {\n    if (this.config.selectedRCAMeasurements.length > 0) {\n      if (isDevMode()) {\n      console.log('Selected RCA Measurements', this.config.selectedRCAMeasurements);}\n    }\n  }\n  openColorPicker() {\n    if (!this.isOpenCP) {\n      this.isOpenCP = true;\n    }\n  }\n  openBorderColorPicker() {\n    if (!this.borderCP) {\n      this.borderCP = true;\n    }\n  }\n  closeColorPicker() {\n    if (this.isOpenCP) {\n      this.isOpenCP = false;\n    }\n  }\n  closeBorderColorPicker() {\n    if (this.borderCP) {\n      this.borderCP = false;\n    }\n  }\n  setSelectedColor(value: string) {\n    if (this.config.color) {\n      this.config.color = this.config.color + ';' + value;\n    } else {\n      this.config.color = value;\n    }\n  }\n  setSelectedBorderColor(value: string) {\n    if (this.config.borderColor) {\n      this.config.borderColor = this.config.borderColor + ';' + value;\n    } else {\n      this.config.borderColor = value;\n    }\n  }\n  ngDoCheck(): void {\n    if (this.config.device && this.config.device.id !== this.deviceId) {\n      this.deviceId = this.config.device.id;\n      this.ListMeasurementType = [];\n      this.getmeasurement();\n    }\n  }\n}\n","/**\n * Copyright (c) 2020 Software AG, Darmstadt, Germany and/or its licensors\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Component, Output, EventEmitter, HostListener, ElementRef } from '@angular/core';\n\n@Component({\n  // tslint:disable-next-line: component-selector\n  selector: 'app-color-picker',\n  templateUrl: './color-picker-component.html',\n  styleUrls: ['./color-picker-component.css'],\n})\nexport class ColorPickerComponent {\n  @Output() colorSet: EventEmitter<string> = new EventEmitter(true);\n  @Output() closeColorPicker: EventEmitter<boolean> = new EventEmitter();\n  public hue!: string;\n  public color!: string;\n  public colorType: any;\n  constructor(private eRef: ElementRef) {}\n  applyColorClicked() {\n    if (this.color !== undefined) {\n      if (this.colorType === 'hexa') {\n        this.colorSet.emit(this.RGBAToHexA(this.color));\n      } else {\n        this.colorSet.emit(this.color);\n      }\n    }\n  }\n\n  RGBAToHexA(rgba: any) {\n    const sep = rgba.indexOf(',') > -1 ? ',' : ' ';\n    rgba = rgba.substr(5).split(')')[0].split(sep);\n\n    // Strip the slash if using space-separated syntax\n    if (rgba.indexOf('/') > -1) {\n      rgba.splice(3, 1);\n    }\n\n    let r = (+rgba[0]).toString(16);\n    let g = (+rgba[1]).toString(16);\n    let b = (+rgba[2]).toString(16);\n    let a = Math.round(+rgba[3] * 255).toString(16);\n\n    if (r.length === 1) {\n      r = '0' + r;\n    }\n    if (g.length === 1) {\n      g = '0' + g;\n    }\n    if (b.length === 1) {\n      b = '0' + b;\n    }\n    if (a.length === 1) {\n      a = '0' + a;\n    }\n\n    return '#' + r + g + b + a;\n  }\n\n  @HostListener('document:click', ['$event'])\n  onClick(event: any) {\n    if (\n      this.eRef.nativeElement.contains(event.target) ||\n      (event.target.attributes.id &&\n        (event.target.attributes.id.nodeValue === 'colorInput' ||\n          event.target.attributes.id.nodeValue === 'colorInputBorder'))\n    ) {\n    } else {\n      this.closeColorPicker.emit(false);\n    }\n  }\n}\n","/**\n * Copyright (c) 2020 Software AG, Darmstadt, Germany and/or its licensors\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Component,\n  ElementRef,\n  ViewChild,\n  HostListener,\n  Output,\n  EventEmitter,\n} from '@angular/core';\n\n@Component({\n  // tslint:disable-next-line: component-selector\n  selector: 'app-color-slider',\n  templateUrl: './color-slider-component.html',\n})\nexport class ColorSliderComponent {\n  @Output()\n  color: EventEmitter<string> = new EventEmitter(true);\n\n  @ViewChild('canvas', { static: true })\n  canvas!: ElementRef<HTMLCanvasElement>;\n\n  private ctx: any;\n  private mousedown = false;\n  private selectedHeight!: number;\n\n  // tslint:disable-next-line: use-lifecycle-interface\n  ngAfterViewInit() {\n    this.draw();\n  }\n  onMouseDown(evt: MouseEvent) {\n    this.mousedown = true;\n    this.selectedHeight = evt.offsetY;\n    this.draw();\n    this.emitColor(evt.offsetX, evt.offsetY);\n  }\n  onMouseMove(evt: MouseEvent) {\n    if (this.mousedown) {\n      this.selectedHeight = evt.offsetY;\n      this.draw();\n      this.emitColor(evt.offsetX, evt.offsetY);\n    }\n  }\n  @HostListener('window:mouseup', ['$event'])\n  onMouseUp(evt: MouseEvent) {\n    this.mousedown = false;\n  }\n  emitColor(x: number, y: number) {\n    const rgbaColor = this.getColorAtPosition(x, y);\n    this.color.emit(rgbaColor);\n  }\n  getColorAtPosition(x: number, y: number) {\n    const imageData = this.ctx.getImageData(x, y, 1, 1).data;\n    return 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';\n  }\n  draw() {\n    if (!this.ctx) {\n      this.ctx = this.canvas.nativeElement.getContext('2d');\n    }\n\n    const width = this.canvas.nativeElement.width;\n    const height = this.canvas.nativeElement.height;\n    this.ctx.clearRect(0, 0, width, height);\n\n    const gradient = this.ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgba(255, 0, 0, 1)');\n    gradient.addColorStop(0.17, 'rgba(255, 255, 0, 1)');\n    gradient.addColorStop(0.34, 'rgba(0, 255, 0, 1)');\n    gradient.addColorStop(0.51, 'rgba(0, 255, 255, 1)');\n    gradient.addColorStop(0.68, 'rgba(0, 0, 255, 1)');\n    gradient.addColorStop(0.85, 'rgba(255, 0, 255, 1)');\n    gradient.addColorStop(1, 'rgba(255, 0, 0, 1)');\n\n    this.ctx.beginPath();\n    this.ctx.rect(0, 0, width, height);\n    this.ctx.fillStyle = gradient;\n    this.ctx.fill();\n    this.ctx.closePath();\n\n    if (this.selectedHeight) {\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = 'white';\n      this.ctx.lineWidth = 5;\n      this.ctx.rect(0, this.selectedHeight - 5, width, 10);\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }\n  }\n}\n","/**\n * Copyright (c) 2020 Software AG, Darmstadt, Germany and/or its licensors\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Component,\n  ViewChild,\n  ElementRef,\n  AfterViewInit,\n  Input,\n  Output,\n  SimpleChanges,\n  OnChanges,\n  EventEmitter,\n  HostListener,\n} from '@angular/core';\n\n@Component({\n  // tslint:disable-next-line: component-selector\n  selector: 'app-color-palette',\n  templateUrl: './color-palette-component.html',\n  styleUrls: ['./color-palette-component.css'],\n})\nexport class ColorPaletteComponent implements AfterViewInit, OnChanges {\n  @Input()\n  hue!: string;\n\n  @Output()\n  color: EventEmitter<string> = new EventEmitter(true);\n\n  @ViewChild('canvas', { static: true })\n  canvas!: ElementRef<HTMLCanvasElement>;\n\n  private ctx: any;\n\n  private mousedown = false;\n\n  public selectedPosition!: { x: number; y: number };\n\n  ngAfterViewInit() {\n    this.draw();\n  }\n\n  draw() {\n    if (!this.ctx) {\n      this.ctx = this.canvas.nativeElement.getContext('2d');\n    }\n    const width = this.canvas.nativeElement.width;\n    const height = this.canvas.nativeElement.height;\n\n    this.ctx.fillStyle = this.hue || 'rgba(255,255,255,1)';\n    this.ctx.fillRect(0, 0, width, height);\n\n    const whiteGrad = this.ctx.createLinearGradient(0, 0, width, 0);\n    whiteGrad.addColorStop(0, 'rgba(255,255,255,1)');\n    whiteGrad.addColorStop(1, 'rgba(255,255,255,0)');\n\n    this.ctx.fillStyle = whiteGrad;\n    this.ctx.fillRect(0, 0, width, height);\n\n    const blackGrad = this.ctx.createLinearGradient(0, 0, 0, height);\n    blackGrad.addColorStop(0, 'rgba(0,0,0,0)');\n    blackGrad.addColorStop(1, 'rgba(0,0,0,1)');\n\n    this.ctx.fillStyle = blackGrad;\n    this.ctx.fillRect(0, 0, width, height);\n\n    if (this.selectedPosition) {\n      this.ctx.strokeStyle = 'white';\n      this.ctx.fillStyle = 'white';\n      this.ctx.beginPath();\n      this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 10, 0, 2 * Math.PI);\n      this.ctx.lineWidth = 5;\n      this.ctx.stroke();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // tslint:disable-next-line: no-string-literal\n    if (changes['hue']) {\n      this.draw();\n      const pos = this.selectedPosition;\n      if (pos) {\n        this.color.emit(this.getColorAtPosition(pos.x, pos.y));\n      }\n    }\n  }\n\n  @HostListener('window:mouseup', ['$event'])\n  onMouseUp(evt: MouseEvent) {\n    this.mousedown = false;\n  }\n\n  onMouseDown(evt: MouseEvent) {\n    this.mousedown = true;\n    this.selectedPosition = { x: evt.offsetX, y: evt.offsetY };\n    this.draw();\n    this.color.emit(this.getColorAtPosition(evt.offsetX, evt.offsetY));\n  }\n\n  onMouseMove(evt: MouseEvent) {\n    if (this.mousedown) {\n      this.selectedPosition = { x: evt.offsetX, y: evt.offsetY };\n      this.draw();\n      this.emitColor(evt.offsetX, evt.offsetY);\n    }\n  }\n\n  emitColor(x: number, y: number) {\n    const rgbaColor = this.getColorAtPosition(x, y);\n    this.color.emit(rgbaColor);\n  }\n\n  getColorAtPosition(x: number, y: number) {\n    const imageData = this.ctx.getImageData(x, y, 1, 1).data;\n    return 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { GpLibRcaComponent } from './gp-lib-rca.component';\nimport { GpLibRcaService } from './gp-lib-rca.service';\nimport { CommonModule, CoreModule, HOOK_COMPONENTS } from '@c8y/ngx-components';\nimport { ChartsModule } from 'ng2-charts';\nimport { GpLibRcaConfigComponent } from './gp-lib-rca.config.component';\nimport { Commonc8yService } from './Commonc8yservice.service';\nimport { BsModalService, ModalModule } from 'ngx-bootstrap/modal';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { RCAViewModalComponent } from './rca-view-modal/rca-view-modal.component';\nimport { NgSelectModule } from '@ng-select/ng-select';\nimport { ColorPickerComponent } from './color-picker/color-picker-component';\nimport { ColorSliderComponent } from './color-picker/color-slider/color-slider-component';\nimport { ColorPaletteComponent } from './color-picker/color-palette/color-palette-component';\nimport * as preview from './preview-image';\n\n@NgModule({\n  declarations: [\n    GpLibRcaComponent,\n    GpLibRcaConfigComponent,\n    RCAViewModalComponent,\n    ColorPickerComponent,\n    ColorSliderComponent,\n    ColorPaletteComponent,\n  ],\n  imports: [\n    CoreModule,\n    CommonModule,\n    ModalModule.forRoot(),\n    FormsModule,\n    NgSelectModule,\n    ReactiveFormsModule,\n    ChartsModule,\n  ],\n  exports: [\n    GpLibRcaComponent,\n    GpLibRcaConfigComponent,\n    RCAViewModalComponent,\n    ColorPickerComponent,\n  ],\n  entryComponents: [\n    GpLibRcaComponent,\n    GpLibRcaConfigComponent,\n    RCAViewModalComponent,\n    ColorPickerComponent,\n  ],\n  providers: [\n    GpLibRcaService,\n    BsModalService,\n    Commonc8yService,\n    {\n      provide: HOOK_COMPONENTS,\n      multi: true,\n      useValue: {\n        id: 'rca-chart.widget',\n        label: 'RCA Chart',\n        previewImage: preview.previewImage,\n        description: 'Display the RCA whenever AD > 1',\n        component: GpLibRcaComponent,\n        configComponent: GpLibRcaConfigComponent,\n        data: {\n          ng1: {\n            options: {\n              noDeviceTarget: false,\n              noNewWidgets: false,\n              deviceTargetNotRequired: false,\n              groupsSelectable: true,\n            },\n          },\n        },\n      },\n    },\n  ],\n})\nexport class GpLibRcaModule {}\n"],"sourceRoot":""}